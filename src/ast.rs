use string_cache::Atom;

// @TODO: Contexts should probably be copy rather than move...

/// The particular context which an identifier lives in. This allows
/// for the sanitation of identifiers in different scopes
#[deriving(Show, PartialEq, Eq, Hash, Clone)]
pub enum Context {
    /// Internal identifiers are generated by, for example, the type checking process
    /// Their Atom values are mostly useless for non-display purposes
    Internal(uint),
    /// BuiltIn identifiers are identifiers built in to the runtime, such as
    /// Int, Float, Bool, Str, etc.
    BuiltIn,
    /// TODO: Actually create User identifiers
    /// User identifiers are uniqued identifiers created by the user. They
    /// should have been created from Unresolved identifiers during the
    /// Scoping step
    User,
    /// Unresolved identifiers are non-scoped identifiers read in from the parser
    /// They should be scoped into User identifiers asap, so that the uniqueness
    /// property is maintained
    Unresolved,
}

/// An identifier in the source, such as `foo` or `Int` 
#[deriving(Show, PartialEq, Eq, Hash, Clone)]
pub struct Ident {
    /// This is the visual representation of an identifier It is interned for cheap comps
    symbol: Atom,
    ctx: Context,
}

impl Ident {
    pub fn from_atom(atom: &Atom) -> Ident {
        Ident{
            symbol: atom.clone(),
            ctx: Context::Unresolved,
        }
    }
    
    pub fn from_slice(s: &str) -> Ident {
        Ident{
            symbol: Atom::from_slice(s),
            ctx: Context::Unresolved,
        }
    }
    
    pub fn builtin(s: &str) -> Ident {
        Ident{
            symbol: Atom::from_slice(s),
            ctx: Context::BuiltIn,
        }
    }
}

/* Types */

/// A type in the ducky programming language. Types can take the form of
/// a Ident (which refers either to another type, or is generic over all types)
/// or a Record (which is a set of key-value pairs), or a function.
#[deriving(Show, PartialEq, Eq, Hash, Clone)]
pub enum Ty {
    Ident{ ident: Ident },
    Rec{
        extends: Option<Box<Ty>>,
        props: Vec<PropTy>,
    },
    Fn{
        params: Vec<Ty>,
        result: Box<Ty>,
    },
}

#[deriving(Show, PartialEq, Eq, Hash, Clone)]
pub struct PropTy {
    pub symbol: Atom,
    pub ty: Ty,
}

#[deriving(Show, Clone)]
pub enum Expr {
    Ident {
        ident: Ident,
        ty: Option<Ty>,
    },
    Literal {
        value: Literal,
    },
    Rec {
        props: Vec<Prop>,
        ty: Option<Ty>,
    },
    Lookup {
        record: Box<Expr>,
        prop: Atom,
        ty: Option<Ty>,
    },
    Call {
        callee: Box<Expr>,
        args: Vec<Expr>,
        ty: Option<Ty>,
    },
    Fn {
        params: Vec<Ident>,
        body: Box<Expr>,
        ty: Option<Ty>,
    },
    Block {
        statements: Vec<Stmt>,
        ty: Option<Ty>,
    },
}

// const STRING_TYPE: Ty = Ty::Ident(Ident{
//     symbol: atom!("String"),
//     context: BuiltIn
// });

#[allow(non_snake_case)]
pub mod STATIC {
    #![allow(non_upper_case_globals)]

    use string_cache::Atom;
    use ast::*;
    macro_rules! builtin_ident {
        ($str:expr) => {
            Ident{
                symbol: Atom::from_slice($str),
                ctx: Context::BuiltIn,
            }
        }
    }

    lazy_static! {
        pub static ref StringTy: Ty = Ty::Ident{ident: String.clone()};
        pub static ref IntTy: Ty = Ty::Ident{ident: Int.clone()};
        pub static ref FloatTy: Ty = Ty::Ident{ident: Float.clone()};
        pub static ref BoolTy: Ty = Ty::Ident{ident: Bool.clone()};

        pub static ref String: Ident = builtin_ident!("String");
        pub static ref Int: Ident = builtin_ident!("Int");
        pub static ref Float: Ident = builtin_ident!("Float");
        pub static ref Bool: Ident = builtin_ident!("Bool");
    }
}

impl Expr {
    pub fn get_ty(&self) -> Option<Ty> {
        match *self {
            Expr::Literal{ value: Literal::Str(..) } => Some(STATIC::StringTy.clone()),
            Expr::Literal{ value: Literal::Int(..) } => Some(STATIC::IntTy.clone()),
            Expr::Literal{ value: Literal::Float(..) } => Some(STATIC::FloatTy.clone()),
            Expr::Literal{ value: Literal::Bool(..) } => Some(STATIC::BoolTy.clone()),
            
            Expr::Ident{ ref ty, .. } => ty.clone(),
            Expr::Rec{ ref ty, .. } => ty.clone(),
            Expr::Lookup{ ref ty, .. } => ty.clone(),
            Expr::Call{ ref ty, .. } => ty.clone(),
            Expr::Fn{ ref ty, .. } => ty.clone(),
            Expr::Block{ ref ty, .. } => ty.clone(),
        }
    }
    
    pub fn set_ty(&mut self, ty: Option<Ty>) {
        match *self {
            Expr::Literal{ .. } => {
                if self.get_ty() != ty { panic!("Cannot set literal to incorrect type!"); }
            }
            Expr::Ident{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
            Expr::Rec{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
            Expr::Lookup{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
            Expr::Call{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
            Expr::Fn{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
            Expr::Block{ ty: ref mut ity, .. } => {
                if let Some(..) = *ity {
                    panic!("Cannot set type of literal twice!")
                }
                *ity = ty 
            }
        }
    }
}

#[deriving(Show, Clone)]
pub enum Literal {
    Str(Atom),
    Int(i64),
    Float(f64),
    Bool(bool),
}

#[deriving(Show, Clone)]
pub struct Prop {
    pub symbol: Atom,
    pub val: Expr,
}

#[deriving(Show, Clone)]
pub enum Stmt {
    Let {
        ident: Ident,
        value: Expr,
    },
    Expr {
        value: Expr,
    },
    Empty,
}
